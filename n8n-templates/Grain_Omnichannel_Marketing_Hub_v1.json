{
  "name": "Grain Omnichannel Marketing Hub v1",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "omnichannel-campaign",
        "options": {}
      },
      "id": "campaign-webhook",
      "name": "Campaign Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 400],
      "webhookId": "omnichannel-campaign"
    },
    {
      "parameters": {
        "jsCode": "// Parse and orchestrate omnichannel campaign\nconst campaign = $input.first().json.body;\n\nconst campaignData = {\n  campaignId: `OMC-${Date.now().toString(36).toUpperCase()}`,\n  name: campaign.name,\n  objective: campaign.objective,\n  targetAudience: campaign.targetAudience,\n  channels: campaign.channels || ['email', 'sms', 'push', 'social'],\n  content: campaign.content,\n  schedule: campaign.schedule,\n  segmentation: campaign.segmentation,\n  budget: campaign.budget,\n  startDate: campaign.startDate,\n  endDate: campaign.endDate,\n  status: 'active',\n  createdAt: new Date().toISOString()\n};\n\n// Generate channel-specific content variants\nconst channelContent = {};\ncampaignData.channels.forEach(channel => {\n  channelContent[channel] = {\n    enabled: true,\n    status: 'pending',\n    content: campaign.content[channel] || campaign.content.default\n  };\n});\n\ncampaignData.channelContent = channelContent;\n\nreturn [{ json: campaignData }];"
      },
      "id": "parse-campaign",
      "name": "Parse Campaign",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $vars.CDP_API_URL }}/segments/{{ $json.segmentation.segmentId }}/users",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "limit",
              "value": "10000"
            },
            {
              "name": "include_preferences",
              "value": "true"
            }
          ]
        },
        "options": {}
      },
      "id": "fetch-audience",
      "name": "Fetch Target Audience",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [750, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "cdp-api-key",
          "name": "CDP API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Segment users by preferred channels\nconst campaign = $('Parse Campaign').first().json;\nconst users = $input.first().json.users || [];\n\nconst channelSegments = {\n  email: [],\n  sms: [],\n  push: [],\n  social: [],\n  whatsapp: []\n};\n\nusers.forEach(user => {\n  const preferences = user.communication_preferences || {};\n  const optedIn = user.opt_in_status || {};\n  \n  // Prioritize by engagement and preference\n  if (campaign.channels.includes('email') && optedIn.email && user.email) {\n    channelSegments.email.push({\n      userId: user.id,\n      email: user.email,\n      firstName: user.first_name,\n      lastName: user.last_name,\n      engagementScore: user.email_engagement_score || 50,\n      lastEmailOpen: user.last_email_open\n    });\n  }\n  \n  if (campaign.channels.includes('sms') && optedIn.sms && user.phone) {\n    channelSegments.sms.push({\n      userId: user.id,\n      phone: user.phone,\n      firstName: user.first_name,\n      carrier: user.phone_carrier\n    });\n  }\n  \n  if (campaign.channels.includes('push') && optedIn.push && user.push_token) {\n    channelSegments.push.push({\n      userId: user.id,\n      pushToken: user.push_token,\n      platform: user.device_platform,\n      firstName: user.first_name\n    });\n  }\n  \n  if (campaign.channels.includes('whatsapp') && optedIn.whatsapp && user.whatsapp_number) {\n    channelSegments.whatsapp.push({\n      userId: user.id,\n      phone: user.whatsapp_number,\n      firstName: user.first_name\n    });\n  }\n  \n  // Social retargeting audience\n  if (campaign.channels.includes('social')) {\n    channelSegments.social.push({\n      userId: user.id,\n      email: user.email,\n      externalIds: user.external_ids\n    });\n  }\n});\n\nreturn [{\n  json: {\n    campaign,\n    channelSegments,\n    summary: {\n      totalUsers: users.length,\n      email: channelSegments.email.length,\n      sms: channelSegments.sms.length,\n      push: channelSegments.push.length,\n      whatsapp: channelSegments.whatsapp.length,\n      social: channelSegments.social.length\n    }\n  }\n}];"
      },
      "id": "segment-by-channel",
      "name": "Segment by Channel",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-email",
              "leftValue": "={{ $json.summary.email }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-email",
      "name": "Has Email?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.EMAIL_API_URL }}/campaigns/send",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"campaign_id\": \"{{ $('Parse Campaign').first().json.campaignId }}\",\n  \"name\": \"{{ $('Parse Campaign').first().json.name }}\",\n  \"subject\": \"{{ $('Parse Campaign').first().json.content.email.subject }}\",\n  \"html_content\": {{ JSON.stringify($('Parse Campaign').first().json.content.email.body) }},\n  \"recipients\": {{ JSON.stringify($json.channelSegments.email) }},\n  \"send_at\": \"{{ $('Parse Campaign').first().json.schedule.email || 'now' }}\"\n}",
        "options": {}
      },
      "id": "send-email",
      "name": "Send Email Campaign",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1500, 100],
      "credentials": {
        "httpHeaderAuth": {
          "id": "email-api-key",
          "name": "Email API Key"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-sms",
              "leftValue": "={{ $json.summary.sms }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-sms",
      "name": "Has SMS?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/{{ $vars.TWILIO_ACCOUNT_SID }}/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "MessagingServiceSid",
              "value": "={{ $vars.TWILIO_MESSAGING_SERVICE }}"
            },
            {
              "name": "Body",
              "value": "={{ $('Parse Campaign').first().json.content.sms.body }}"
            }
          ]
        },
        "options": {}
      },
      "id": "send-sms-batch",
      "name": "Send SMS Batch",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1500, 300],
      "credentials": {
        "twilioApi": {
          "id": "twilio-credential",
          "name": "Twilio API"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-push",
              "leftValue": "={{ $json.summary.push }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-push",
      "name": "Has Push?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 600]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://onesignal.com/api/v1/notifications",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"app_id\": \"{{ $vars.ONESIGNAL_APP_ID }}\",\n  \"include_player_ids\": {{ JSON.stringify($json.channelSegments.push.map(u => u.pushToken)) }},\n  \"headings\": { \"en\": \"{{ $('Parse Campaign').first().json.content.push.title }}\" },\n  \"contents\": { \"en\": \"{{ $('Parse Campaign').first().json.content.push.body }}\" },\n  \"url\": \"{{ $('Parse Campaign').first().json.content.push.url }}\"\n}",
        "options": {}
      },
      "id": "send-push",
      "name": "Send Push Notifications",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1500, 500],
      "credentials": {
        "httpHeaderAuth": {
          "id": "onesignal-api",
          "name": "OneSignal API"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-social",
              "leftValue": "={{ $json.summary.social }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-social",
      "name": "Has Social?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 800]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://graph.facebook.com/v19.0/act_{{ $vars.META_AD_ACCOUNT_ID }}/customaudiences",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "facebookGraphApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"name\": \"{{ $('Parse Campaign').first().json.name }} - Retargeting\",\n  \"subtype\": \"CUSTOM\",\n  \"description\": \"Omnichannel campaign audience\",\n  \"customer_file_source\": \"USER_PROVIDED_ONLY\"\n}",
        "options": {}
      },
      "id": "create-custom-audience",
      "name": "Create Custom Audience",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1500, 700],
      "credentials": {
        "facebookGraphApi": {
          "id": "meta-ads-credential",
          "name": "Meta Ads API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Aggregate results from all channels\nconst campaign = $('Parse Campaign').first().json;\nconst segmentData = $('Segment by Channel').first().json;\n\nconst results = {\n  campaignId: campaign.campaignId,\n  campaignName: campaign.name,\n  status: 'sent',\n  channels: {},\n  summary: segmentData.summary,\n  completedAt: new Date().toISOString()\n};\n\n// Collect results from each channel\ntry {\n  const emailResult = $('Send Email Campaign').first()?.json;\n  if (emailResult) {\n    results.channels.email = {\n      status: 'sent',\n      recipients: segmentData.summary.email,\n      messageId: emailResult.id\n    };\n  }\n} catch (e) {}\n\ntry {\n  const smsResult = $('Send SMS Batch').first()?.json;\n  if (smsResult) {\n    results.channels.sms = {\n      status: 'sent',\n      recipients: segmentData.summary.sms\n    };\n  }\n} catch (e) {}\n\ntry {\n  const pushResult = $('Send Push Notifications').first()?.json;\n  if (pushResult) {\n    results.channels.push = {\n      status: 'sent',\n      recipients: pushResult.recipients || segmentData.summary.push,\n      notificationId: pushResult.id\n    };\n  }\n} catch (e) {}\n\ntry {\n  const socialResult = $('Create Custom Audience').first()?.json;\n  if (socialResult) {\n    results.channels.social = {\n      status: 'audience_created',\n      audienceId: socialResult.id,\n      audienceSize: segmentData.summary.social\n    };\n  }\n} catch (e) {}\n\nreturn [{ json: results }];"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1750, 400]
    },
    {
      "parameters": {
        "channel": "={{ $vars.MARKETING_SLACK_CHANNEL }}",
        "text": "=üì£ *Omnichannel Campaign Launched!*\n\n*Campaign:* {{ $json.campaignName }}\n*ID:* {{ $json.campaignId }}\n\nüìä *Channel Summary:*\n{{ $json.summary.email > 0 ? `‚Ä¢ üìß Email: ${$json.summary.email} recipients` : '' }}\n{{ $json.summary.sms > 0 ? `‚Ä¢ üì± SMS: ${$json.summary.sms} recipients` : '' }}\n{{ $json.summary.push > 0 ? `‚Ä¢ üîî Push: ${$json.summary.push} recipients` : '' }}\n{{ $json.summary.social > 0 ? `‚Ä¢ üåê Social: ${$json.summary.social} audience` : '' }}\n\n*Total Reach:* {{ $json.summary.totalUsers }} users\n\n_Campaign tracking enabled across all channels_",
        "otherOptions": {}
      },
      "id": "notify-launch",
      "name": "Notify Launch",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.2,
      "position": [2000, 300],
      "credentials": {
        "slackApi": {
          "id": "slack-credential",
          "name": "Slack API"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "={{ $vars.CAMPAIGN_LOG_SHEET_ID }}",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "Omnichannel Campaigns",
          "mode": "list",
          "cachedResultName": "Omnichannel Campaigns"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Campaign ID": "={{ $json.campaignId }}",
            "Campaign Name": "={{ $json.campaignName }}",
            "Status": "={{ $json.status }}",
            "Total Reach": "={{ $json.summary.totalUsers }}",
            "Email": "={{ $json.summary.email }}",
            "SMS": "={{ $json.summary.sms }}",
            "Push": "={{ $json.summary.push }}",
            "Social": "={{ $json.summary.social }}",
            "Launched At": "={{ $json.completedAt }}"
          }
        },
        "options": {}
      },
      "id": "log-campaign",
      "name": "Log Campaign",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [2000, 500],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "google-sheets-credential",
          "name": "Google Sheets OAuth2"
        }
      }
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 24
            }
          ]
        }
      },
      "id": "daily-report",
      "name": "Daily Report",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [250, 700]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $vars.ANALYTICS_API_URL }}/campaigns/performance",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "date_range",
              "value": "last_24h"
            },
            {
              "name": "group_by",
              "value": "channel,campaign_id"
            }
          ]
        },
        "options": {}
      },
      "id": "fetch-performance",
      "name": "Fetch Performance Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [500, 700],
      "credentials": {
        "httpHeaderAuth": {
          "id": "analytics-api-key",
          "name": "Analytics API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Analyze cross-channel performance\nconst data = $input.first().json;\n\nconst channelMetrics = {\n  email: { sent: 0, delivered: 0, opens: 0, clicks: 0, conversions: 0, revenue: 0 },\n  sms: { sent: 0, delivered: 0, clicks: 0, conversions: 0, revenue: 0 },\n  push: { sent: 0, delivered: 0, clicks: 0, conversions: 0, revenue: 0 },\n  social: { impressions: 0, clicks: 0, conversions: 0, spend: 0, revenue: 0 }\n};\n\n// Aggregate metrics by channel\n(data.campaigns || []).forEach(campaign => {\n  const channel = campaign.channel;\n  if (channelMetrics[channel]) {\n    Object.keys(campaign.metrics).forEach(metric => {\n      if (channelMetrics[channel][metric] !== undefined) {\n        channelMetrics[channel][metric] += campaign.metrics[metric] || 0;\n      }\n    });\n  }\n});\n\n// Calculate derived metrics\nObject.keys(channelMetrics).forEach(channel => {\n  const m = channelMetrics[channel];\n  if (channel === 'email') {\n    m.openRate = m.delivered > 0 ? ((m.opens / m.delivered) * 100).toFixed(2) : 0;\n    m.clickRate = m.opens > 0 ? ((m.clicks / m.opens) * 100).toFixed(2) : 0;\n    m.conversionRate = m.clicks > 0 ? ((m.conversions / m.clicks) * 100).toFixed(2) : 0;\n  } else if (channel === 'sms' || channel === 'push') {\n    m.clickRate = m.delivered > 0 ? ((m.clicks / m.delivered) * 100).toFixed(2) : 0;\n    m.conversionRate = m.clicks > 0 ? ((m.conversions / m.clicks) * 100).toFixed(2) : 0;\n  } else if (channel === 'social') {\n    m.ctr = m.impressions > 0 ? ((m.clicks / m.impressions) * 100).toFixed(2) : 0;\n    m.roas = m.spend > 0 ? (m.revenue / m.spend).toFixed(2) : 0;\n    m.cpa = m.conversions > 0 ? (m.spend / m.conversions).toFixed(2) : 0;\n  }\n});\n\n// Overall totals\nconst totals = {\n  totalReach: channelMetrics.email.delivered + channelMetrics.sms.delivered + channelMetrics.push.delivered + channelMetrics.social.impressions,\n  totalClicks: Object.values(channelMetrics).reduce((sum, c) => sum + (c.clicks || 0), 0),\n  totalConversions: Object.values(channelMetrics).reduce((sum, c) => sum + (c.conversions || 0), 0),\n  totalRevenue: Object.values(channelMetrics).reduce((sum, c) => sum + (c.revenue || 0), 0)\n};\n\nreturn [{ json: { channelMetrics, totals, reportDate: new Date().toISOString() } }];"
      },
      "id": "analyze-performance",
      "name": "Analyze Performance",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [750, 700]
    },
    {
      "parameters": {
        "channel": "={{ $vars.MARKETING_SLACK_CHANNEL }}",
        "text": "=üìä *Daily Omnichannel Performance Report*\n\n*Overall Metrics:*\n‚Ä¢ Total Reach: {{ $json.totals.totalReach.toLocaleString() }}\n‚Ä¢ Total Clicks: {{ $json.totals.totalClicks.toLocaleString() }}\n‚Ä¢ Total Conversions: {{ $json.totals.totalConversions }}\n‚Ä¢ Total Revenue: ${{ $json.totals.totalRevenue.toLocaleString() }}\n\nüìß *Email:*\n‚Ä¢ Open Rate: {{ $json.channelMetrics.email.openRate }}%\n‚Ä¢ Click Rate: {{ $json.channelMetrics.email.clickRate }}%\n‚Ä¢ Conversions: {{ $json.channelMetrics.email.conversions }}\n\nüì± *SMS:*\n‚Ä¢ Click Rate: {{ $json.channelMetrics.sms.clickRate }}%\n‚Ä¢ Conversions: {{ $json.channelMetrics.sms.conversions }}\n\nüîî *Push:*\n‚Ä¢ Click Rate: {{ $json.channelMetrics.push.clickRate }}%\n‚Ä¢ Conversions: {{ $json.channelMetrics.push.conversions }}\n\nüåê *Social:*\n‚Ä¢ CTR: {{ $json.channelMetrics.social.ctr }}%\n‚Ä¢ ROAS: {{ $json.channelMetrics.social.roas }}x\n‚Ä¢ CPA: ${{ $json.channelMetrics.social.cpa }}",
        "otherOptions": {}
      },
      "id": "notify-performance",
      "name": "Notify Performance",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.2,
      "position": [1000, 700],
      "credentials": {
        "slackApi": {
          "id": "slack-credential",
          "name": "Slack API"
        }
      }
    }
  ],
  "connections": {
    "Campaign Trigger": {
      "main": [
        [{ "node": "Parse Campaign", "type": "main", "index": 0 }]
      ]
    },
    "Parse Campaign": {
      "main": [
        [{ "node": "Fetch Target Audience", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Target Audience": {
      "main": [
        [{ "node": "Segment by Channel", "type": "main", "index": 0 }]
      ]
    },
    "Segment by Channel": {
      "main": [
        [
          { "node": "Has Email?", "type": "main", "index": 0 },
          { "node": "Has SMS?", "type": "main", "index": 0 },
          { "node": "Has Push?", "type": "main", "index": 0 },
          { "node": "Has Social?", "type": "main", "index": 0 }
        ]
      ]
    },
    "Has Email?": {
      "main": [
        [{ "node": "Send Email Campaign", "type": "main", "index": 0 }],
        []
      ]
    },
    "Has SMS?": {
      "main": [
        [{ "node": "Send SMS Batch", "type": "main", "index": 0 }],
        []
      ]
    },
    "Has Push?": {
      "main": [
        [{ "node": "Send Push Notifications", "type": "main", "index": 0 }],
        []
      ]
    },
    "Has Social?": {
      "main": [
        [{ "node": "Create Custom Audience", "type": "main", "index": 0 }],
        []
      ]
    },
    "Send Email Campaign": {
      "main": [
        [{ "node": "Aggregate Results", "type": "main", "index": 0 }]
      ]
    },
    "Send SMS Batch": {
      "main": [
        [{ "node": "Aggregate Results", "type": "main", "index": 0 }]
      ]
    },
    "Send Push Notifications": {
      "main": [
        [{ "node": "Aggregate Results", "type": "main", "index": 0 }]
      ]
    },
    "Create Custom Audience": {
      "main": [
        [{ "node": "Aggregate Results", "type": "main", "index": 0 }]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          { "node": "Notify Launch", "type": "main", "index": 0 },
          { "node": "Log Campaign", "type": "main", "index": 0 }
        ]
      ]
    },
    "Daily Report": {
      "main": [
        [{ "node": "Fetch Performance Data", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Performance Data": {
      "main": [
        [{ "node": "Analyze Performance", "type": "main", "index": 0 }]
      ]
    },
    "Analyze Performance": {
      "main": [
        [{ "node": "Notify Performance", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    { "id": "marketing", "name": "marketing" },
    { "id": "omnichannel", "name": "omnichannel" },
    { "id": "automation", "name": "automation" }
  ],
  "triggerCount": 2,
  "updatedAt": "2026-01-07T00:00:00.000Z",
  "versionId": "1"
}
